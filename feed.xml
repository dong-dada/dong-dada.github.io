<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2024-09-04T04:58:02+00:00</updated><id>/feed.xml</id><title type="html">董哒哒</title><subtitle>我哒哒的马蹄是美丽的错误，我不是归人，是个过客</subtitle><entry><title type="html">RDMA 学习</title><link href="/2024/08/28/rdma-learn.html" rel="alternate" type="text/html" title="RDMA 学习" /><published>2024-08-28T04:00:00+00:00</published><updated>2024-08-28T04:00:00+00:00</updated><id>/2024/08/28/rdma-learn</id><content type="html" xml:base="/2024/08/28/rdma-learn.html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#概述" id="markdown-toc-概述">概述</a></li>
  <li><a href="#verbs-api" id="markdown-toc-verbs-api">Verbs API</a>    <ul>
      <li><a href="#服务类型" id="markdown-toc-服务类型">服务类型</a></li>
      <li><a href="#rc-建连" id="markdown-toc-rc-建连">RC 建连</a></li>
      <li><a href="#操作类型" id="markdown-toc-操作类型">操作类型</a>        <ul>
          <li><a href="#sendrecv" id="markdown-toc-sendrecv">Send&amp;Recv</a></li>
          <li><a href="#write" id="markdown-toc-write">Write</a></li>
          <li><a href="#read" id="markdown-toc-read">Read</a></li>
        </ul>
      </li>
      <li><a href="#memory-region" id="markdown-toc-memory-region">Memory Region</a></li>
    </ul>
  </li>
  <li><a href="#参考资料" id="markdown-toc-参考资料">参考资料</a></li>
</ul>

<h2 id="概述">概述</h2>

<p>RDMA 是 Remote Direct Memory Access 的缩写，意为”远程直接内存访问”，它的基本原理是绕过 CPU 和 操作系统，让通信两端的网卡直接访问用户态内存，完成数据传输。</p>

<p>这种做法省去了上下文切换、内存拷贝、协议处理等开销，在数据传输时能达到较高的带宽和延迟指标：</p>

<p><img src="/images/networking/traditional-vs-rdma.png" alt="" /></p>

<p>RDMA 技术有几种不同的协议栈实现，但在应用层提供了统一的接口，称为 Verbs API:</p>

<p><img src="/images/networking/rdma-protocol-stack.png" alt="" /></p>

<p>InfiniBand 协议栈需要添置专门的网络设备，无法兼容现有以太网，除了需要支持 IB 的网卡，还需要配套的交换设备。RoCE 协议栈可以看作是“低成本解决方案”，目的是在以太网中运行 RDMA。早期的 RoCE 仅支持在二层以太网上实现 RDMA 传输，换句话说报文没法被路由器路由，使用场景受限。随后的 RoCEv2 把报文封装在了 UDP/IP 报文内，可以跨越子网路由，解除了诸多限制，逐渐流行起来。</p>

<p>值得注意的是上图左侧标明的 “Hardware”，就是说 RDMA 协议栈需要专门的网卡实现，一般网卡是不行的。</p>

<p>下图是 RoCE 和 RoCEv2 的报文结构：</p>

<p><img src="/images/networking/roce-packet-format.jpeg" alt="" /></p>

<p>RoCEv2 可以工作在 lossless 和 lossy 网络下：</p>
<ul>
  <li>Lossless，也就是无损以太网，要求网络中没有差错、丢包、乱序。实现 lossless 需要支持该功能的网卡、交换机，并进行相应的网络配置。涉及的技术包括：
    <ul>
      <li>PFC: Priority Flow Control, 基于优先级的流量控制，让 RDMA 流量具有更高的优先级。</li>
      <li>DCB: Data Center Bridging, 增强的以太网协议，支持无损传输。</li>
      <li>ECN: Explicit Congestion Notification, 显式拥塞通知，交换机发生拥塞会显式通知发送方，发送方可以降低速率。</li>
    </ul>
  </li>
  <li>Lossy, 也就是有损网络，自 CX5 系列网卡开始支持 RoCE 的增强功能，使得组网规模不大的情况下，也能在 lossy 网络中运行。</li>
</ul>

<h2 id="verbs-api">Verbs API</h2>

<p>跟 Socket API 相比，Verbs API 有些复杂，首先需要理解队列模型：</p>

<p><img src="/images/networking/rdma-consumer-queuing-model.png" alt="" /></p>

<p>通过 Verbs API 进行数据传输时，需要向 Work Queue 里投递 Work Request, 网卡(HCA)从队列里取出 WQE 执行相应操作，结束后会投递一个 CQE 到 Completion Queue 里，应用层可以从这个队列中取出 Work Completion 得知处理结果。</p>

<p>以下代码片段展示了这一过程:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">main</span> <span class="p">{</span>
    <span class="c1">// QP 建连、注册 MR 等过程，省略。。。</span>

    <span class="c1">// 要发送的内存块信息</span>
    <span class="n">ibv_sge</span> <span class="n">sg</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">local_mr</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span>
        <span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">local_mr</span><span class="p">.</span><span class="n">length</span><span class="p">,</span>
        <span class="p">.</span><span class="n">lkey</span> <span class="o">=</span> <span class="n">local_mr</span><span class="p">.</span><span class="n">lkey</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="c1">// 构造 Work Request, 内容为使用 WRITE 操作，将内存块写入目标地址</span>
    <span class="n">ibv_send_wr</span> <span class="n">write_wr</span><span class="p">{</span>
        <span class="p">.</span><span class="n">wr_id</span> <span class="o">=</span> <span class="n">wr_id</span><span class="p">,</span>
        <span class="p">.</span><span class="n">sg_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sg</span><span class="p">,</span>                     <span class="c1">// 要发送的内存块</span>
        <span class="p">.</span><span class="n">num_sge</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="p">.</span><span class="n">opcode</span> <span class="o">=</span> <span class="n">IBV_WR_RDMA_WRITE</span><span class="p">,</span>        <span class="c1">// 操作方式</span>
        <span class="p">.</span><span class="n">send_flags</span> <span class="o">=</span> <span class="n">IBV_SEND_SIGNALED</span><span class="p">,</span>
        <span class="p">.</span><span class="n">wr</span> <span class="o">=</span> <span class="p">{</span>
            <span class="p">.</span><span class="n">rdma</span> <span class="o">=</span> <span class="p">{</span>
                <span class="p">.</span><span class="n">remote_addr</span> <span class="o">=</span> <span class="n">remote_addr</span><span class="p">,</span> <span class="c1">// 远端内存地址信息</span>
                <span class="p">.</span><span class="n">rkey</span> <span class="o">=</span> <span class="n">remote_key</span><span class="p">,</span>
            <span class="p">},</span>
        <span class="p">},</span>
    <span class="p">};</span>

    <span class="c1">// 将 Work Request 投递到 Send Queue</span>
    <span class="n">ibv_send_wr</span><span class="o">*</span> <span class="n">bad_send_wr</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ibv_post_send</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_qp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">write_wr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bad_send_wr</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"Failed to post write wr, errno: %d(%s)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">errno</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">sleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>

    <span class="c1">// 从 Completion Queue 里取出 Work Completion</span>
    <span class="n">ibv_wc</span> <span class="n">wc_list</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ibv_poll_cq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_cq</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">wc_list</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"Failed to poll work completions from cq, errno: %d(%s)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">errno</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 检查是否执行成功</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">wc</span><span class="p">.</span><span class="n">status</span> <span class="o">!=</span> <span class="n">IBV_WC_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Failed WC status %d(%s) for wr_id %lu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">wc</span><span class="p">.</span><span class="n">status</span><span class="p">,</span> <span class="n">ibv_wc_status_str</span><span class="p">(</span><span class="n">wc</span><span class="p">.</span><span class="n">status</span><span class="p">),</span> <span class="n">wc</span><span class="p">.</span><span class="n">wr_id</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>理解了队列模型之后，剩余的概念就比较好解释了：</p>

<table>
  <thead>
    <tr>
      <th>概念</th>
      <th>缩写</th>
      <th>解释</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Send Queue</td>
      <td>SQ</td>
      <td>发送队列，顾名思义用于存放发送任务。<br />在 API 中使用 <code class="language-plaintext highlighter-rouge">ibv_post_send()</code> 方法向该队列投递任务，对应结构体 <code class="language-plaintext highlighter-rouge">ibv_send_wr</code></td>
    </tr>
    <tr>
      <td>Receive Queue</td>
      <td>RQ</td>
      <td>接收队列，用于存放接收任务。<br />适用于 SEND&amp;RECV 操作，在这种操作模式下，不仅发送方需要向 SQ 中投递发送任务，接收方也需要在 RQ 中投递接收任务，这样才能收到数据。<br />在 API 中使用 <code class="language-plaintext highlighter-rouge">ibv_recv_wr</code> 投递接收任务，对应结构体 <code class="language-plaintext highlighter-rouge">ibv_recv_wr</code></td>
    </tr>
    <tr>
      <td>Queue Pair</td>
      <td>QP</td>
      <td>也就是一对 SQ 和 RQ。<br />QP 和 QP 之间可以绑定起来建立连接关系。<br />QP 有一个编号来标识，称为 Queue Pair Number, 简称 QPN。</td>
    </tr>
    <tr>
      <td>Shared Receive Queue</td>
      <td>SRQ</td>
      <td>多个 QP 共享一个 Receive Queue, 从上面讨论可以看出 Receive Queue 的使用频率比较低，大多数情况下是在使用 Send Queue, 因此可以通过共享来节省资源。</td>
    </tr>
    <tr>
      <td>Memory Region</td>
      <td>MR</td>
      <td>用户态申请的内存不能直接被网卡访问，需要先注册到 Memory Region 上。<br />在 API 中使用 <code class="language-plaintext highlighter-rouge">ibv_reg_mr()</code> 注册 MR, 使用 <code class="language-plaintext highlighter-rouge">ibv_dereg_mr()</code> 取消注册，对应结构体 <code class="language-plaintext highlighter-rouge">ibv_mr</code></td>
    </tr>
    <tr>
      <td>Memory Window</td>
      <td>MW</td>
      <td>相当于时 MR 上某个区域的视图，可以针对这个视图做权限修改，相比于重新注册 MR 来说速度很快。</td>
    </tr>
    <tr>
      <td>Protection Domain</td>
      <td>PD</td>
      <td>用于保护各类资源，包括 QP, MR 等，相当于对这些资源进行分组，不同组的资源彼此隔离。<br />在 API 中使用 <code class="language-plaintext highlighter-rouge">ibv_create_qp()</code> 创建 PD, 使用 <code class="language-plaintext highlighter-rouge">ibv_dealloc_pd()</code> 释放 PD, 对应结构体 <code class="language-plaintext highlighter-rouge">ibv_pd</code></td>
    </tr>
    <tr>
      <td>Completion Queue</td>
      <td>CQ</td>
      <td>完成队列，硬件每处理完一个 WQE，就会投递一个 CQE 到 CQ 里面。应用可以从中获取出 Work Completion，得知处理结果。<br />注意一个 CQ 可以为多个 QP 提供服务。<br />在 API 中使用 <code class="language-plaintext highlighter-rouge">ibv_poll_cq()</code> 获取 WC, 对应结构体 <code class="language-plaintext highlighter-rouge">ibv_wc</code></td>
    </tr>
    <tr>
      <td>Completion Event Channel</td>
      <td> </td>
      <td>能够使用事件驱动的方式来获取 WC, 而不是通过 poll 模式获取。可以跟若干 CQ 关联起来，每当 CQ 上有了 WC，就可以从 Channnel 中收到事件通知。<br />在 API 中使用 <code class="language-plaintext highlighter-rouge">ibv_create_comp_channel()</code> 创建 channel，使用 <code class="language-plaintext highlighter-rouge">ibv_create_cq()</code> 创建 CQ 时传入 channel 即可进行绑定，使用 <code class="language-plaintext highlighter-rouge">ibv_req_notify_cq()</code> 要求 CQ 通过 channel 进行事件通知，使用 <code class="language-plaintext highlighter-rouge">ibv_get_cq_event()</code> 从 Channel 中阻塞式地获取 CQE, 使用 <code class="language-plaintext highlighter-rouge">ibv_ack_cq_events()</code> 确认 CQE。Channel 中有个 fd, 可以跟 epoll 结合使用，[这篇文章](https://rustmagazine.github.io/rust_magazine_2021/chapter_5/rust-epoll-rdma.html) 描述了具体做法。<br />相比 Poll 模式，这种方式可以节省 CPU 占用，但性能上有一定损失。事件模式 和 Poll 模式可以结合使用，在收到事件之后的一段时间内轮询调用 <code class="language-plaintext highlighter-rouge">ibv_poll_cq()</code> 主动获取 WC。</td>
    </tr>
  </tbody>
</table>

<p>RDMA 通信过程可以分为以下几个步骤：</p>
<ul>
  <li>创建资源，包括 PD, QP, CQ, CompChannel 等。</li>
  <li>建立连接</li>
  <li>注册内存到 MR，这一步是比较耗时的，通常需要对注册好的内存池化管理。</li>
  <li>数据传输</li>
</ul>

<h3 id="服务类型">服务类型</h3>

<p>基于 QP 的服务类型通过 “可靠性” 和 “连接” 两个维度划分为四种：</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>可靠(Reliable)</th>
      <th>不可靠(Unreliable)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>连接</td>
      <td>RC(Reliable Connection)</td>
      <td>UC(Unreliable Connection)</td>
    </tr>
    <tr>
      <td>数据报</td>
      <td>RD(Reliable Datagram)</td>
      <td>UD(Unreliable Datagram)</td>
    </tr>
  </tbody>
</table>

<p>可以看到 RC 类似于 TCP, 通信之前要先建立连接；UD 类似于 TCP，每次发送都需要传入地址信息。</p>

<h3 id="rc-建连">RC 建连</h3>

<p>在 TCP 中，建立连接需要 IP 和 Port 两个信息，在 RDMA 中建立 RC 连接需要哪些信息呢？</p>

<p>虽然 RoCEv2 是基于 UDP 的，但它遵循的是 IB 协议，因此从 API 层面并不能看到 UDP 的 IP 和 Port 信息。以下是 RDMA 中地址信息相关的概念：</p>

<table>
  <thead>
    <tr>
      <th>概念</th>
      <th>缩写</th>
      <th>解释</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Global Identifier</td>
      <td>GID</td>
      <td>类似于 IP 地址在 TCP/IP 网络中的作用。是一个 128 位的地址，由 64 位的子网前缀和 64 位的接口标识符组成。用于跨越子网的通信。<br />RoCE 中的 GID 通常由 IPv6 派生而来。</td>
    </tr>
    <tr>
      <td>Local Identifier</td>
      <td>LID</td>
      <td>类似于 MAC 地址。是一个 16 位的局部标识符，用于标识 InfiniBand 子网中的某个设备。用于子网内的通信。<br />RoCE 中不需要，它基于 MAC 地址进行子网内部通信。</td>
    </tr>
    <tr>
      <td>Port Number</td>
      <td> </td>
      <td>RDMA设备(如 HCA, Host Channel Adapter 也就是网卡)上通常有多个物理端口，每个端口连接到一个独立的网络。这个物理端口以 Port Number 序号进行标识，通常从 1 开始编号。<br />每个端口都有独立的地址信息，包括 GID, LID 等，因此先要指定 Port Number 才能找到 GID</td>
    </tr>
    <tr>
      <td>GID Index</td>
      <td> </td>
      <td>每个 Port Number 对应的物理端口上，可以有多个 GID，这些 GID 组成了一个 GID 表，GID Index 就是表中的索引。<br />这个 GID 表通常用于支持不同类型的地址，比如基于 LID 的 GID、IPv6 地址。 <br />对于 RoCE 来说, Index 为 0 的 GID 由 MAC 地址生成，Index 为 1 的 GID 由 IPv4 地址生成，Index 为 2 的 GID 由 IPv6 地址生成。</td>
    </tr>
    <tr>
      <td>Queue Pair Number</td>
      <td>QPN</td>
      <td>即 QP 的编号</td>
    </tr>
    <tr>
      <td>Packet Sequence Number</td>
      <td>PSN</td>
      <td>类似于 TCP 握手时交换的 seq 序号，在 RC 建连时需要手动指定。</td>
    </tr>
    <tr>
      <td>Address Handle</td>
      <td>AH</td>
      <td>封装了地址信息，用于 UD 服务类型，每次发送都需要填入目标地址，AH 提供了目标地址信息的封装，免得每次重新创建。</td>
    </tr>
  </tbody>
</table>

<p>从上面内容来看，建立 RC 连接时至少需要收集 GID, QPN, PSN 这三项信息。以下代码展示了如何获得这些信息:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="n">kPortNum</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>   <span class="c1">// 选择默认物理端口</span>
    <span class="kt">int</span> <span class="n">kGidIndex</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>      <span class="c1">// 选择 IPv6 GID</span>

    <span class="c1">// 打开设备</span>
    <span class="n">ibv_context</span><span class="o">*</span> <span class="n">context</span> <span class="o">=</span> <span class="n">ibv_open_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>

    <span class="c1">// 创建 QP, 省略 PD 等细节</span>
    <span class="n">ibv_qp</span><span class="o">*</span> <span class="n">qp</span> <span class="o">=</span> <span class="n">ibv_create_qp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qp_init_attr</span><span class="p">);</span>
    
    <span class="c1">// 查询 GID</span>
    <span class="n">ibv_gid</span> <span class="n">gid</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ibv_query_gid</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">kPortNum</span><span class="p">,</span> <span class="n">kGidIndex</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gid</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"Failed to query gid, port_num: %d, gid_index: %d, errno: %d(%s)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">port_num</span><span class="p">,</span> <span class="n">gid_index</span><span class="p">,</span> <span class="n">errno</span><span class="p">,</span>
             <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 查询 QPN</span>
    <span class="kt">uint32_t</span> <span class="n">qpn</span> <span class="o">=</span> <span class="n">qp</span><span class="p">.</span><span class="n">qp_num</span><span class="p">;</span>

    <span class="c1">// 生成 PSN</span>
    <span class="kt">int</span> <span class="n">psn</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">lrand48</span><span class="p">()</span> <span class="o">&amp;</span> <span class="mh">0xffffff</span><span class="p">);</span>

    <span class="c1">// 通过带外方式，通信双方交换 GID, QPN, PSN 信息</span>
    <span class="c1">// 随后进行 RC 建连</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这些信息的交换是带外的，RDMA CM(Communication Manager) 是一个专门用来做连接管理的库。也可以使用 TCP 连接等方式来交换信息。</p>

<p>拿到这些信息之后，需要调用 <code class="language-plaintext highlighter-rouge">ibv_modify_qp()</code> 方法，建立 RC 连接。建连的过程稍微有些复杂，需要执行三次 modify qp 操作，逐步切换状态: Reset -&gt; Initialized -&gt; Read to Receive -&gt; Ready to Send</p>

<p><img src="/images/networking/rdma-qp-state.png" alt="" /></p>

<h3 id="操作类型">操作类型</h3>

<p>RDMA 提供了几种不同的操作类型，用于不同场景:</p>

<h4 id="sendrecv">Send&amp;Recv</h4>

<p>如下图，这种方式需要通信两端都都参与，发送方投递 SEND 任务，接收方投递 RECV 任务：</p>
<ul>
  <li>这种方式适合于发送一些控制消息，不太适合大块数据的传输。</li>
  <li>它要求接收方提前投递 RECV 任务到接收队列里面，并且接收方需要准备一块内存来接收数据。</li>
  <li>在这种方式下，接收方能够通过 CQ 判断是否有新数据到来。</li>
</ul>

<p><img src="/images/networking/rdma-send-recv.png" alt="" /></p>

<h4 id="write">Write</h4>

<p>如下图，这种方式是单端操作，接收方需要事先准备一块内存，并且把内存信息通过某种方式告知给发送方，发送方将自己数据写入到接收方的内存中，写入的过程不需要接收方参与。</p>
<ul>
  <li>接收方可以通过 Send&amp;Recv 的方式将自己的内存信息告诉发送方。</li>
  <li>接收方默认是不知道数据已经收到的，发送方可以在发送时指定 IBV_WR_RDMA_WRITE_WITH_IMM, 这样接收方会在 RQ 里额外收到一个消息。当然发送方也可以在 WRITE 完成之后再通过 Send&amp;Recv 通知一下接收方。</li>
</ul>

<p><img src="/images/networking/rdma-write.png" alt="" /></p>

<h4 id="read">Read</h4>

<p>Read 操作是跟 Write 相反的过程，是从远端拷贝一份数据到本端上。同样远端需要事先通过某种方式把内存信息告知过来。</p>
<ul>
  <li>同样的，远端机器并不知道自己的数据已经被读取完成了，需要本端通过 Send&amp;Recv 等方式通知远端。</li>
</ul>

<p><img src="/images/networking/rdma-read.png" alt="" /></p>

<h3 id="memory-region">Memory Region</h3>

<p>调用 <code class="language-plaintext highlighter-rouge">ibv_reg_mr()</code> 即可将一块用户态内存注册到 MR 中:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ibv_mr</span><span class="o">*</span> <span class="nf">allocMemAndRegMr</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">mem_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 申请内存，并且要求进行页对齐</span>
    <span class="c1">// 对齐并不是强制的，但是 ChatGPT 说页对齐之后性能会好点，没找到出处</span>
    <span class="c1">// rdma-core 的 pingpong 示例程序里也是进行了页对齐的</span>
    <span class="kt">size_t</span> <span class="n">alignment</span> <span class="o">=</span> <span class="n">_SC_PAGESIZE</span><span class="p">;</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">mem_addr</span> <span class="o">=</span> <span class="n">memalign</span><span class="p">(</span><span class="n">alignment</span><span class="p">,</span> <span class="n">mem_size</span><span class="p">);</span>

    <span class="c1">// 指定 MR 的访问权限</span>
    <span class="kt">int</span> <span class="n">access_flags_int</span> <span class="o">=</span> <span class="n">IBV_ACCESS_LOCAL_WRITE</span> <span class="o">|</span> <span class="n">IBV_ACCESS_REMOTE_WRITE</span><span class="p">;</span>

    <span class="c1">// 注册到 MR 上</span>
    <span class="n">ibv_mr</span><span class="o">*</span> <span class="n">mr</span> <span class="o">=</span> <span class="n">ibv_reg_mr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_pd</span><span class="p">,</span> <span class="n">mem_addr</span><span class="p">,</span> <span class="n">mem_size</span><span class="p">,</span> <span class="n">access_flags_int</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">mr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>注册后返回的 <code class="language-plaintext highlighter-rouge">ibv_mr</code> 是个结构体，其中包含了 lkey, rkey 两把钥匙。在执行不同任务时，需要按照需求带上相应的 key。具体可以参考 <a href="https://www.rdmamojo.com/2012/09/07/ibv_reg_mr/">RDMAmojo</a>.</p>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://www.rdmamojo.com/">RDMAmojo</a></li>
  <li><a href="https://www.zhihu.com/column/c_1231181516811390976">RDMA杂谈 - 知乎</a></li>
  <li><a href="http://www.bj-joynet.com/static/upload/file/20221025/1666684563267006.pdf">端到端RoCE概念原理与部署调优</a></li>
  <li><a href="https://01.me/projects/SocksDirect/sigcomm19-transcription/">BojieLi</a></li>
  <li><a href="https://openucx.readthedocs.io/en/master/index.html">OpenUCX</a> 高性能通信框架</li>
</ul>]]></content><author><name></name></author><summary type="html"><![CDATA[概述 Verbs API 服务类型 RC 建连 操作类型 Send&amp;Recv Write Read Memory Region 参考资料]]></summary></entry><entry><title type="html">std::shared_ptr 的线程安全性</title><link href="/2024/08/27/shared-ptr-thread-safe.html" rel="alternate" type="text/html" title="std::shared_ptr 的线程安全性" /><published>2024-08-27T04:00:00+00:00</published><updated>2024-08-27T04:00:00+00:00</updated><id>/2024/08/27/shared-ptr-thread-safe</id><content type="html" xml:base="/2024/08/27/shared-ptr-thread-safe.html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#线程安全性" id="markdown-toc-线程安全性">线程安全性</a></li>
  <li><a href="#实现原理" id="markdown-toc-实现原理">实现原理</a></li>
  <li><a href="#应用" id="markdown-toc-应用">应用</a></li>
</ul>

<h2 id="线程安全性">线程安全性</h2>

<p>关于 <code class="language-plaintext highlighter-rouge">std::shared_ptr</code> 的线程安全性, <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr">cppreference</a> 中提到:</p>
<blockquote>
  <p>All member functions (including copy constructor and copy assignment) can be called by multiple threads on different shared_ptr objects without additional synchronization even if these objects are copies and share ownership of the same object. If multiple threads of execution access the same shared_ptr object without synchronization and any of those accesses uses a non-const member function of shared_ptr then a data race will occur; the std::atomic<shared_ptr> can be used to prevent the data race.</shared_ptr></p>
</blockquote>

<p>前面一句话的意思是“即使不同线程中的不同 shared_ptr 指向相同对象，也可以安全地调用所有成员函数”。后面一句话的意思是“如果在多个线程中访问同一个 shared_ptr 指针，其中有线程使用了非 const 成员，那么会出现发生数据争用，此时可以使用 <code class="language-plaintext highlighter-rouge">std::atomic&lt;shared_ptr&gt;</code>”。</p>

<p>也就是说下面的代码是线程安全的，尽管不能确定对象是在哪个线程中被释放，但是可以保证对象只被释放一次:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p1</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>

  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">([</span><span class="n">p1</span><span class="p">]()</span> <span class="p">{</span>
    <span class="c1">// p1 和 p2 指向同一个对象</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">p1</span><span class="p">;</span>

    <span class="c1">// 释放 p1 和 p2</span>
    <span class="n">p1</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
    <span class="n">p2</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
  <span class="p">});</span>

  <span class="c1">// 释放 p1</span>
  <span class="n">p1</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
  <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>但下面代码不是线程安全的，因为在两个线程中访问了同一个 <code class="language-plaintext highlighter-rouge">std::shared_ptr</code> 指针:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p1</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>

  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">([</span><span class="o">&amp;</span><span class="n">p1</span><span class="p">]()</span> <span class="p">{</span>
    <span class="c1">// 使用 p1</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p1</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">});</span>

  <span class="c1">// 释放 p1</span>
  <span class="n">p1</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
  <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="实现原理">实现原理</h2>

<p>实现上通常是通过原子操作来保障线程安全性的，如以下伪代码所示，通过原子操作可以保证只有一个线程进入析构步骤：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">shared_ptr</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="o">~</span><span class="n">shared_ptr</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 将引用计数原子地减一，返回原先的值</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">shared_count_</span><span class="o">-&gt;</span><span class="n">fetch_sub</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 只会有一个线程进入这个步骤</span>
      <span class="k">delete</span> <span class="n">data_</span><span class="p">;</span>
      <span class="k">delete</span> <span class="n">shared_count_</span><span class="p">;</span>     <span class="c1">// 这一步会有线程安全问题吗？</span>
    <span class="p">}</span>
  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="n">T</span><span class="o">*</span> <span class="n">data_</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">atomic_int</span><span class="o">*</span> <span class="n">shared_count_</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>上述代码中 <code class="language-plaintext highlighter-rouge">delete shared_count_</code> 可能引起疑问，如果在线程 A 中执行了这一句，在线程 B 中又试图访问 <code class="language-plaintext highlighter-rouge">shared_count_</code> 应该会有线程安全问题。</p>

<p>但这种情况只会出现在 “多个线程访问同一个 <code class="language-plaintext highlighter-rouge">shared_ptr</code> 的场景下”，如果我们遵循正确的使用方式，让线程 A 和 B 持有各自的 <code class="language-plaintext highlighter-rouge">shared_ptr</code> 拷贝，那么线程 A 和 B 同时进入析构函数的情况下，<code class="language-plaintext highlighter-rouge">shared_count_</code> 至少是 2，只有在线程 B 已经将其减为 1 的情况下，线程 A 才有机会执行到 <code class="language-plaintext highlighter-rouge">delete shared_count_</code> 这一句。所以上述代码不存在线程安全问题。</p>

<p>总的来说，向其它线程传递 <code class="language-plaintext highlighter-rouge">std::shared_ptr</code> 时应该以拷贝的方式传递，这样就不会有线程安全问题。</p>

<h2 id="应用">应用</h2>

<p>以上内容表明在多个线程中通过不同 <code class="language-plaintext highlighter-rouge">std::shared_ptr</code> 指向同一个对象是线程安全的。当然这是针对 <code class="language-plaintext highlighter-rouge">std::shared_ptr</code> 本身而言，对于它所指向的对象还是需要加锁的。</p>

<p>一种有趣的应用是利用 <code class="language-plaintext highlighter-rouge">std::shared_ptr</code> 的引用计数及自定义析构函数来判断并行的一批任务是否全部完成:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">runOnAllThreads</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">all_threads_complete_cb</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">cb_guard</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">),</span> <span class="p">[</span><span class="n">all_threads_complete_cb</span><span class="p">](</span><span class="kt">int</span><span class="o">*</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 自定义析构函数</span>
    <span class="c1">// 对象被析构意味着所有线程执行完毕</span>
    <span class="n">all_threads_complete_cb</span><span class="p">();</span>
    <span class="k">delete</span> <span class="n">obj</span><span class="p">;</span>
  <span class="p">});</span>

  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="kr">thread</span> <span class="o">:</span> <span class="n">threads</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">thread</span><span class="p">.</span><span class="n">post</span><span class="p">([</span><span class="n">cb_guard</span><span class="p">]()</span> <span class="p">{</span>
      <span class="c1">// 每个线程执行后都触发这个回调</span>
      <span class="c1">// 全部线程执行完毕后, cb_guard 的引用计数减为 0, 触发析构函数</span>
    <span class="p">});</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author></entry><entry><title type="html">Protocol Buffer 学习</title><link href="/2024/08/21/protobuf-learn.html" rel="alternate" type="text/html" title="Protocol Buffer 学习" /><published>2024-08-21T02:57:19+00:00</published><updated>2024-08-21T02:57:19+00:00</updated><id>/2024/08/21/protobuf-learn</id><content type="html" xml:base="/2024/08/21/protobuf-learn.html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#编码" id="markdown-toc-编码">编码</a>    <ul>
      <li><a href="#protoscope-工具" id="markdown-toc-protoscope-工具">Protoscope 工具</a></li>
      <li><a href="#proto2-和-proto3-的编码格式是相同的" id="markdown-toc-proto2-和-proto3-的编码格式是相同的">Proto2 和 Proto3 的编码格式是相同的</a></li>
      <li><a href="#protobuf-编码不具备自解释性" id="markdown-toc-protobuf-编码不具备自解释性">Protobuf 编码不具备自解释性</a></li>
      <li><a href="#protobuf-编码不是稳定的" id="markdown-toc-protobuf-编码不是稳定的">Protobuf 编码不是稳定的</a></li>
      <li><a href="#protobuf-编码没有定界符" id="markdown-toc-protobuf-编码没有定界符">Protobuf 编码没有定界符</a></li>
      <li><a href="#protobuf-编码的尺寸限制" id="markdown-toc-protobuf-编码的尺寸限制">Protobuf 编码的尺寸限制</a></li>
    </ul>
  </li>
  <li><a href="#用法" id="markdown-toc-用法">用法</a>    <ul>
      <li><a href="#googleprotobufany" id="markdown-toc-googleprotobufany">google.protobuf.Any</a></li>
      <li><a href="#googleprotobufstruct" id="markdown-toc-googleprotobufstruct">google.protobuf.Struct</a></li>
      <li><a href="#options" id="markdown-toc-options">Options</a></li>
      <li><a href="#reflection" id="markdown-toc-reflection">Reflection</a></li>
    </ul>
  </li>
  <li><a href="#源码" id="markdown-toc-源码">源码</a>    <ul>
      <li><a href="#数据的存储" id="markdown-toc-数据的存储">数据的存储</a></li>
      <li><a href="#编解码" id="markdown-toc-编解码">编解码</a></li>
      <li><a href="#serialize-接口" id="markdown-toc-serialize-接口">Serialize 接口</a></li>
      <li><a href="#parse-接口" id="markdown-toc-parse-接口">Parse 接口</a></li>
    </ul>
  </li>
</ul>

<p>本文从各种角度讨论 Protobuf 值得关注的点。</p>

<h2 id="编码">编码</h2>

<h3 id="protoscope-工具">Protoscope 工具</h3>

<p><a href="https://github.com/protocolbuffers/protoscope">Protoscope</a> 工具可以把编码后的 PB 数据用人类可读的方式展示出来：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 定义 proto
syntax = "proto3";

message Person {
  int32 id = 1;
  string name = 2;
  string email = 3;
}

// 创建 PB 对象并序列化到 person.pb 文件
int main() {
  Person person;
  person.set_id(42);
  person.set_name("alice");
  person.set_email("hello@outlook.com");

  std::cout &lt;&lt; person.SerializeAsString();

  return 0;
}

// 使用 protoscope 工具查看
$ protoscope -explicit-wire-types -explicit-length-prefixes person.pb
1:VARINT 42
2:LEN 5 "alice"
3:LEN 17 "hello@outlook.com"
</code></pre></div></div>

<h3 id="proto2-和-proto3-的编码格式是相同的">Proto2 和 Proto3 的编码格式是相同的</h3>

<p>Proto2 和 Proto3 在语法上有差异，但在编码格式上是相同的，这意味着可以平滑地把语法从 Proto2 升级到 Proto3。</p>

<h3 id="protobuf-编码不具备自解释性">Protobuf 编码不具备自解释性</h3>

<p>完整的编码格式参考 <a href="https://protobuf.dev/programming-guides/encoding/">这篇文章</a>，这里讨论它的一些特点：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>message    := (tag value)*

tag        := (field &lt;&lt; 3) bit-or wire_type;
                encoded as uint32 varint
value      := varint      for wire_type == VARINT,
              i32         for wire_type == I32,
              i64         for wire_type == I64,
              len-prefix  for wire_type == LEN,
              &lt;empty&gt;     for wire_type == SGROUP or EGROUP
</code></pre></div></div>

<p>可以看出这里的编码思路是将 message 的每个字段编码为 <code class="language-plaintext highlighter-rouge">wire_type-field_number-value</code> 的形式。其中 <code class="language-plaintext highlighter-rouge">wire_type</code> 指明了 value 采用何种编码方式，<code class="language-plaintext highlighter-rouge">field_number</code> 就是 message 中字段的序号, <code class="language-plaintext highlighter-rouge">value</code> 是具体的值。</p>

<p>值得注意的是 <code class="language-plaintext highlighter-rouge">wire_type</code> 并不是跟具体的类型相关的，比如 I32 既可以是 fixed32 也可以是 float，LEN 既可以表示 string 也可以表示内嵌消息，这意味着 Protobuf 的编码格式不具备“自解释性”。</p>

<p>这一点可以从 protoscope 工具看出：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 定义 proto, 注意内嵌消息
syntax = "proto3";

message Person {
  int32 id = 1;
  string name = 2;
  string email = 3;

  message PhoneNumber {
    string number = 1;
    string code = 2;
  }

  PhoneNumber phone = 4;
}

// 创建 PB 对象并序列化
int main() {
  Person person;
  person.set_id(42);
  person.set_name("alice");
  person.set_email("hello@outlook.com");
  person.mutable_phone()-&gt;set_number("12345678900");
  person.mutable_phone()-&gt;set_code("86");

  std::cout &lt;&lt; person.SerializeAsString();
}

// 使用 protoscope 工具查看，它没能正确识别内嵌消息
$ protoscope -explicit-wire-types -explicit-length-prefixes person.pb
1:VARINT 42
2:LEN 5 "alice"
3:LEN 17 "hello@outlook.com"
4:LEN 17
  1:LEN 11
    6:I64 4.663768570166562e-33   # 0x3938373635343332i64
    6:VARINT 48
  2:LEN 2 7:VARINT 54
</code></pre></div></div>

<p>不具备自解释性，使得我们无法编写直接将 PB 数据转换为 json 或者 map 之类的转换器，在处理 PB 数据时必须有 proto 文件才可以。比如 <a href="https://github.com/yinqiwen/pbjson/blob/master/test/test.cpp">pbjson</a> 这个 C++ 库，它提供的 pb2json 方法需要传入 PB message 对象才可以做解析。</p>

<h3 id="protobuf-编码不是稳定的">Protobuf 编码不是稳定的</h3>

<p>就是说相同内容的 PB 对象编码后不一定会产生相同的数据，会有顺序的差别，<a href="https://protobuf.dev/programming-guides/serialization-not-canonical/">这篇文章</a> 解释了为什么设计成这样。</p>

<p>由于编码不稳定，在做比较的时候不能直接比较编码后数据，只能解码之后通过 PB 对象进行比较：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;google/protobuf/util/message_differencer.h&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">MessageDifferencer</span><span class="p">;</span>

<span class="kt">bool</span> <span class="nf">pb_equal</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 直接比较是不行的</span>
    <span class="c1">// return lhs == rhs;</span>

    <span class="k">auto</span> <span class="n">lhs_obj</span> <span class="o">=</span> <span class="n">Person</span><span class="o">::</span><span class="n">ParseFromString</span><span class="p">(</span><span class="n">lhs</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">rhs_obj</span> <span class="o">=</span> <span class="n">Person</span><span class="o">::</span><span class="n">ParseFromString</span><span class="p">(</span><span class="n">rhs</span><span class="p">);</span>

    <span class="c1">// 使用 DebugString 进行比较也是不行的</span>
    <span class="c1">// return lhs_obj.DebugString() == rhs_obj.DebugString();</span>

    <span class="c1">// 应当使用 MessageDifferencer 工具类进行比较</span>
    <span class="c1">// MessageDifferencer 还提供了 Equivalent(), </span>
    <span class="c1">// ApproximatelyEquals(), ApproximatelyEquivalent() 等方法，</span>
    <span class="c1">// 适合不同场景，使用的时候再看看</span>
    <span class="k">return</span> <span class="n">MessageDifferencer</span><span class="o">::</span><span class="n">Equals</span><span class="p">(</span><span class="n">alice</span><span class="p">,</span> <span class="n">bob</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>显然由于不稳定性无法直接从编码后的 PB 数据计算 hash，对于解码后的 PB message 对象，Protobuf 也没有提供计算 hash 的方法。我理解针对 message 对象做 hash 是可以办到的，只是需要明确规定对于 unknown field, default value 的处理方式。</p>

<h3 id="protobuf-编码没有定界符">Protobuf 编码没有定界符</h3>

<p><a href="https://protobuf.dev/programming-guides/techniques/#streaming">这篇文章</a> 介绍了这件事。</p>

<p>因此流式传输的时候需要添加额外的长度字段来标记一份 PB 数据的开始和结束。</p>

<p>这也意味着 PB 解码的时候，传入不完整的数据或者超长的数据，解码不一定会失败。我们不能根据解码是否成功来判断 PB 数据的完整性，必须依靠额外的定界符来判断。</p>

<h3 id="protobuf-编码的尺寸限制">Protobuf 编码的尺寸限制</h3>

<p><a href="https://protobuf.dev/programming-guides/encoding/">Encoding</a> 这篇文章中说明了编码时的尺寸限制：</p>
<ul>
  <li>string, bytes 类型的字段，单个字段不能超过 2GB</li>
  <li>message 整体不能超过 2GB</li>
</ul>

<p>之所以是 2GB 是因为 LEN 类型的 wire_type 使用 int32 类型的 VARINT 来存储长度信息。</p>

<p><a href="https://protobuf.dev/overview/#not-good-fit">这篇文章</a> 提到 Protobuf 不适合存储超过 MB 级别的数据。在 C++ 中，PB 消息的 string, bytes 字段是通过 <code class="language-plaintext highlighter-rouge">std::string</code> 来存储的，因此编解码过程会产生拷贝开销。在 MB 级别数据量的情况下，拷贝开销可以达到 ms 级别，导致编解码性能大受影响。</p>

<p><a href="https://groups.google.com/g/protobuf/c/eNQ02xdhOAE">Protobuf 的讨论组</a> 提到让 string 类型支持 <code class="language-plaintext highlighter-rouge">std::string_view</code> 的事情，用来避免拷贝开销，目前还没有支持。</p>

<h2 id="用法">用法</h2>

<h3 id="googleprotobufany">google.protobuf.Any</h3>

<p><code class="language-plaintext highlighter-rouge">google.protobuf.Any</code> 可以存储任意类型的消息，使用方法:</p>

<div class="language-proto highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="s">"google/protobuf/any.proto"</span><span class="p">;</span>

<span class="kd">message</span> <span class="nc">Error</span> <span class="p">{</span>
  <span class="kt">string</span> <span class="kd">message</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">google.protobuf.Any</span> <span class="na">detail</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 把任意消息编码到 any 字段当中</span>
<span class="n">NetworkErrorDetail</span> <span class="n">detail</span> <span class="o">=</span> <span class="p">...;</span>
<span class="n">Error</span> <span class="n">error</span><span class="p">;</span>
<span class="n">status</span><span class="p">.</span><span class="n">mutable_detail</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">PackFrom</span><span class="p">(</span><span class="n">detail</span><span class="p">);</span>

<span class="c1">// ...</span>

<span class="c1">// 从 any 字段中解码出原始消息</span>
<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">.</span><span class="n">detail</span><span class="p">().</span><span class="n">Is</span><span class="o">&lt;</span><span class="n">NetworkErrorDetail</span><span class="o">&gt;</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">NetworkErrorDetail</span> <span class="n">detail</span><span class="p">;</span>
    <span class="n">status</span><span class="p">.</span><span class="n">detail</span><span class="p">().</span><span class="n">UnpackTo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">detail</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>从 <code class="language-plaintext highlighter-rouge">google.protobuf.Any</code> 消息的定义可以很容易地理解它的工作原理，它只是把任意消息编码为 bytes 存储而已：</p>

<div class="language-proto highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">google</span><span class="o">.</span><span class="n">protobuf</span><span class="p">;</span>

<span class="kd">message</span> <span class="nc">Any</span> <span class="p">{</span>
  <span class="kt">string</span> <span class="na">type_url</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>      <span class="c1">// 原始消息的类型</span>
  <span class="kt">bytes</span> <span class="na">value</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>          <span class="c1">// 编码后的消息</span>
<span class="p">}</span>
</code></pre></div></div>

<p><a href="https://protobuf.dev/programming-guides/techniques/#self-description">这篇文章</a> 提到了使用 Any 和 FileDescriptorSet 实现自解释消息的思路。虽然 Protobuf 编码格式自身不具备自解释性，但是可以把描述信息(也就是 .proto 文件定义的内容)也编码到数据内，使得编码后的数据能够通过反射的方式进行访问。</p>

<h3 id="googleprotobufstruct">google.protobuf.Struct</h3>

<p><code class="language-plaintext highlighter-rouge">google.protobuf.Struct</code> 可以实现像 json 那样的效果，它的定义就是一个 map:</p>

<div class="language-proto highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">message</span> <span class="nc">Struct</span> <span class="p">{</span>
  <span class="n">map</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="n">Value</span><span class="err">&gt;</span> <span class="na">fields</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">message</span> <span class="nc">Value</span> <span class="p">{</span>
  <span class="k">oneof</span> <span class="n">kind</span> <span class="p">{</span>
    <span class="n">NullValue</span> <span class="na">null_value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">double</span> <span class="na">number_value</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="kt">string</span> <span class="na">string_value</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="na">bool_value</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="n">Struct</span> <span class="na">struct_value</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="n">ListValue</span> <span class="na">list_value</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="options">Options</h3>

<p><a href="https://protobuf.dev/programming-guides/proto3/#options">这篇文章</a> 提到 Protobuf 支持在 proto 文件中定义选项:</p>

<div class="language-proto highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">syntax</span> <span class="o">=</span> <span class="s">"proto3"</span><span class="p">;</span>

<span class="c1">// 文件级别的 option</span>
<span class="k">option</span> <span class="na">c_enable_arenas</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>

<span class="kd">message</span> <span class="nc">Person</span> <span class="p">{</span>
  <span class="c1">// 消息级别的 option</span>
  <span class="k">option</span> <span class="na">deprecated</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>

  <span class="kt">int32</span> <span class="na">id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">string</span> <span class="na">name</span> <span class="o">=</span> <span class="mi">2</span> <span class="p">[</span><span class="na">deprecated</span> <span class="o">=</span> <span class="kc">true</span><span class="p">];</span> <span class="c1">// 字段级别的 option</span>
  <span class="kt">string</span> <span class="na">email</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>值得注意的是 <a href="https://github.com/bufbuild/protovalidate">protovalidate</a> 这个项目，使用它可以在 proto 文件中加入一些校验用的 option，protoc 在生成目标代码的时候会产生额外的校验信息，可以验证消息是否满足要求：</p>

<div class="language-proto highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">syntax</span> <span class="o">=</span> <span class="s">"proto3"</span><span class="p">;</span>

<span class="k">import</span> <span class="s">"buf/validate/validate.proto"</span><span class="p">;</span>

<span class="kd">message</span> <span class="nc">Transaction</span> <span class="p">{</span>
  <span class="c1">// 要求 id 值大于 999</span>
  <span class="kt">uint64</span> <span class="na">id</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">[(</span><span class="n">buf.validate.field</span><span class="p">)</span><span class="o">.</span><span class="kt">uint64</span><span class="o">.</span><span class="na">gt</span> <span class="o">=</span> <span class="mi">999</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">"buf/validate/validator.h"</span><span class="cp">
#include</span> <span class="cpf">"path/to/generated/protos/transaction.pb.h"</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">my</span><span class="o">::</span><span class="n">package</span><span class="o">::</span><span class="n">Transaction</span> <span class="n">transaction</span><span class="p">;</span>
  <span class="n">transaction</span><span class="p">.</span><span class="n">set_id</span><span class="p">(</span><span class="mi">1234</span><span class="p">);</span>

  <span class="k">auto</span> <span class="n">factory</span> <span class="o">=</span> <span class="n">buf</span><span class="o">::</span><span class="n">validate</span><span class="o">::</span><span class="n">ValidatorFactory</span><span class="o">::</span><span class="n">New</span><span class="p">().</span><span class="n">value</span><span class="p">();</span>
  <span class="k">auto</span> <span class="n">validator</span> <span class="o">=</span> <span class="n">factory</span><span class="o">-&gt;</span><span class="n">NewValidator</span><span class="p">();</span>

  <span class="c1">// 校验</span>
  <span class="k">auto</span> <span class="n">results</span> <span class="o">=</span> <span class="n">validator</span><span class="p">.</span><span class="n">Validate</span><span class="p">(</span><span class="n">transaction</span><span class="p">).</span><span class="n">value</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">results</span><span class="p">.</span><span class="n">violations_size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"validation failed"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"validation succeeded"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="reflection">Reflection</h3>

<p>通过反射可以在不知道具体类型的情况下访问 PB 对象，比如 pb 转 json 之类的场景就很适合用这种方式:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">JsonValue</span> <span class="nf">pb2json</span><span class="p">(</span><span class="k">const</span> <span class="n">Message</span><span class="o">&amp;</span> <span class="n">message</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Descriptor 描述了消息的静态信息(有哪些字段，每个字段什么类型)</span>
  <span class="c1">// Reflection 记录了消息的动态信息(字段的具体值是什么)</span>
  <span class="k">auto</span> <span class="n">descriptor</span> <span class="o">=</span> <span class="n">message</span><span class="p">.</span><span class="n">GetDescriptor</span><span class="p">();</span>
  <span class="k">auto</span> <span class="n">reflection</span> <span class="o">=</span> <span class="n">message</span><span class="p">.</span><span class="n">GetReflection</span><span class="p">();</span>

  <span class="n">JsonMap</span> <span class="n">json</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">field_count</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">field</span> <span class="o">=</span> <span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">field</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

    <span class="k">auto</span> <span class="n">key</span> <span class="o">=</span> <span class="n">field</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">();</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">field</span><span class="o">-&gt;</span><span class="n">cpp_type</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">case</span> <span class="n">FieldDescriptor</span><span class="o">::</span><span class="n">CPPTYPE_BOOL</span><span class="p">:</span>
        <span class="n">json</span><span class="p">.</span><span class="n">addBool</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">reflection</span><span class="o">-&gt;</span><span class="n">GetBool</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">field</span><span class="p">));</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="n">FieldDescriptor</span><span class="o">::</span><span class="n">CPPTYPE_INT32</span><span class="p">:</span>
        <span class="n">json</span><span class="p">.</span><span class="n">addInt</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">reflection</span><span class="o">-&gt;</span><span class="n">GetInt32</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">field</span><span class="p">));</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="n">FieldDescriptor</span><span class="o">::</span><span class="n">CPPTYPE_MESSAGE</span><span class="p">:</span>
        <span class="n">json</span><span class="p">.</span><span class="n">addValue</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">pb2json</span><span class="p">(</span><span class="n">reflection</span><span class="o">-&gt;</span><span class="n">GetMessage</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">field</span><span class="p">)));</span>
        <span class="k">break</span><span class="p">;</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">json</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="源码">源码</h2>

<h3 id="数据的存储">数据的存储</h3>

<p>从 .proto 文件生成的 PB 对象会有相应字段来存储数据：</p>

<div class="language-proto highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">message</span> <span class="nc">Person</span> <span class="p">{</span>
  <span class="kt">int32</span> <span class="na">id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">string</span> <span class="na">name</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="kt">string</span> <span class="na">email</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

  <span class="kd">message</span> <span class="nc">PhoneNumber</span>
  <span class="p">{</span>
    <span class="kt">string</span> <span class="na">zip_code</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">string</span> <span class="na">number</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">PhoneNumber</span> <span class="na">phone</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Person_PhoneNumber</span> <span class="k">final</span> <span class="o">:</span> <span class="k">public</span> <span class="o">::</span><span class="n">PROTOBUF_NAMESPACE_ID</span><span class="o">::</span><span class="n">Message</span> <span class="p">{</span>
<span class="nl">private:</span>
  <span class="n">internal</span><span class="o">::</span><span class="n">ArenaStringPtr</span> <span class="n">zip_code_</span><span class="p">;</span>
  <span class="n">internal</span><span class="o">::</span><span class="n">ArenaStringPtr</span> <span class="n">number_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Person</span> <span class="k">final</span> <span class="o">:</span> <span class="k">public</span> <span class="o">::</span><span class="n">PROTOBUF_NAMESPACE_ID</span><span class="o">::</span><span class="n">Message</span> <span class="p">{</span>
<span class="nl">private:</span>
  <span class="n">int32</span> <span class="n">id_</span><span class="p">;</span>
  <span class="n">internal</span><span class="o">::</span><span class="n">ArenaStringPtr</span> <span class="n">name_</span><span class="p">;</span>
  <span class="n">internal</span><span class="o">::</span><span class="n">ArenaStringPtr</span> <span class="n">email_</span><span class="p">;</span>
  <span class="o">::</span><span class="n">Person_PhoneNumber</span><span class="o">*</span> <span class="n">phone_</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>其中 ArenaStringPtr 跟 <a href="https://protobuf.dev/reference/cpp/arenas/">Arena 机制</a> 有关，没开启 arena 的话可以认为它是一个 <code class="language-plaintext highlighter-rouge">std::string</code> 指针。</p>

<h3 id="编解码">编解码</h3>

<p>生成的 PB 对象中有相应的编解码方法，当调用父类 <code class="language-plaintext highlighter-rouge">google::protobuf::MessageLite</code> 的编解码方法时，会触发 PB 对象的编解码方法:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Person</span> <span class="k">final</span> <span class="o">:</span> <span class="k">public</span> <span class="o">::</span><span class="n">PROTOBUF_NAMESPACE_ID</span><span class="o">::</span><span class="n">Message</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">size_t</span> <span class="n">ByteSizeLong</span><span class="p">()</span> <span class="k">const</span> <span class="k">final</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">_InternalParse</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">internal</span><span class="o">::</span><span class="n">ParseContext</span><span class="o">*</span> <span class="n">ctx</span><span class="p">)</span> <span class="k">final</span><span class="p">;</span>
  <span class="n">uint8</span><span class="o">*</span> <span class="n">_InternalSerialize</span><span class="p">(</span><span class="n">uint8</span><span class="o">*</span> <span class="n">target</span><span class="p">,</span> <span class="n">io</span><span class="o">::</span><span class="n">EpsCopyOutputStream</span><span class="o">*</span> <span class="n">stream</span><span class="p">)</span> <span class="k">const</span> <span class="k">final</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">uint8</span><span class="o">*</span> <span class="n">Person</span><span class="o">::</span><span class="n">_InternalSerialize</span><span class="p">(</span><span class="n">uint8</span><span class="o">*</span> <span class="n">target</span><span class="p">,</span> <span class="n">io</span><span class="o">::</span><span class="n">EpsCopyOutputStream</span><span class="o">*</span> <span class="n">stream</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">target</span> <span class="o">=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">EnsureSpace</span><span class="p">(</span><span class="n">target</span><span class="p">);</span>
    <span class="n">target</span> <span class="o">=</span> <span class="n">internal</span><span class="o">::</span><span class="n">WireFormatLite</span><span class="o">::</span><span class="n">WriteInt32ToArray</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">_internal_id</span><span class="p">(),</span> <span class="n">target</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">().</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">target</span> <span class="o">=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">WriteStringMaybeAliased</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">_internal_name</span><span class="p">(),</span> <span class="n">target</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">email</span><span class="p">().</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">target</span> <span class="o">=</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">WriteStringMaybeAliased</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">_internal_email</span><span class="p">(),</span> <span class="n">target</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">Person</span><span class="o">::</span><span class="n">_InternalParse</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">internal</span><span class="o">::</span><span class="n">ParseContext</span><span class="o">*</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">Done</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">uint32</span> <span class="n">tag</span><span class="p">;</span>
    <span class="n">ptr</span> <span class="o">=</span> <span class="n">internal</span><span class="o">::</span><span class="n">ReadTag</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tag</span><span class="p">);</span>

    <span class="c1">// tag &gt;&gt; 3 得到 field number</span>
    <span class="c1">// 根据 field number 执行不同的解析方法</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">tag</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">id_</span> <span class="o">=</span> <span class="n">internal</span><span class="o">::</span><span class="n">ReadVarint64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">auto</span> <span class="n">name</span> <span class="o">=</span> <span class="n">_internal_mutable_name</span><span class="p">();</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="o">::</span><span class="n">PROTOBUF_NAMESPACE_ID</span><span class="o">::</span><span class="n">internal</span><span class="o">::</span><span class="n">InlineGreedyStringParser</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">auto</span> <span class="n">email</span> <span class="o">=</span> <span class="n">_internal_mutable_email</span><span class="p">();</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="o">::</span><span class="n">PROTOBUF_NAMESPACE_ID</span><span class="o">::</span><span class="n">internal</span><span class="o">::</span><span class="n">InlineGreedyStringParser</span><span class="p">(</span><span class="n">email</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="c1">// ...</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">size_t</span> <span class="n">Person</span><span class="o">::</span><span class="n">ByteSizeLong</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
  <span class="kt">size_t</span> <span class="n">total_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">total_size</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">internal</span><span class="o">::</span><span class="n">WireFormatLite</span><span class="o">::</span><span class="n">Int32Size</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_internal_id</span><span class="p">());</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">().</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">total_size</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">internal</span><span class="o">::</span><span class="n">WireFormatLite</span><span class="o">::</span><span class="n">StringSize</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_internal_name</span><span class="p">());</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">email</span><span class="p">().</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">total_size</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">+</span> <span class="o">::</span><span class="n">internal</span><span class="o">::</span><span class="n">WireFormatLite</span><span class="o">::</span><span class="n">StringSize</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_internal_email</span><span class="p">());</span>
  <span class="p">}</span>

  <span class="c1">// ...</span>

  <span class="kt">int</span> <span class="n">cached_size</span> <span class="o">=</span> <span class="o">::</span><span class="n">internal</span><span class="o">::</span><span class="n">ToCachedSize</span><span class="p">(</span><span class="n">total_size</span><span class="p">);</span>
  <span class="n">SetCachedSize</span><span class="p">(</span><span class="n">cached_size</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">total_size</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>值得注意的是 <code class="language-plaintext highlighter-rouge">ByteSizeLong()</code> 方法每次执行都会遍历所有字段，在延迟敏感场景下它对性能带来的影响不可忽视。可以看到上述代码中最后一段执行了 <code class="language-plaintext highlighter-rouge">SetCachedSize()</code> 方法来缓存总大小，这个缓存起来的值需要通过 <code class="language-plaintext highlighter-rouge">GetCachedSize()</code> 获取，在需要时可以调用该方法，但是要注意保证消息没有被改动过。</p>

<h3 id="serialize-接口">Serialize 接口</h3>

<p>PB 对象的基类 <code class="language-plaintext highlighter-rouge">google::protobuf::MessageLite</code> 提供了许多序列化用的方法:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MessageLite</span> <span class="p">{</span>
  <span class="kt">bool</span> <span class="n">SerializeToCodedStream</span><span class="p">(</span><span class="n">io</span><span class="o">::</span><span class="n">CodedOutputStream</span><span class="o">*</span> <span class="n">output</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">SerializeToZeroCopyStream</span><span class="p">(</span><span class="n">io</span><span class="o">::</span><span class="n">ZeroCopyOutputStream</span><span class="o">*</span> <span class="n">output</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">SerializeToString</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span> <span class="n">output</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">SerializeToArray</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">SerializeAsString</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">SerializeToFileDescriptor</span><span class="p">(</span><span class="kt">int</span> <span class="n">file_descriptor</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">SerializeToOstream</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">*</span> <span class="n">output</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">AppendToString</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span> <span class="n">output</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// SerializePartial* 系列，与上述方法对应，只是不会检查 required 字段是否被设置</span>
  <span class="kt">bool</span> <span class="n">SerializePartialToCodedStream</span><span class="p">(</span><span class="n">io</span><span class="o">::</span><span class="n">CodedOutputStream</span><span class="o">*</span> <span class="n">output</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">SerializePartialToZeroCopyStream</span><span class="p">(</span><span class="n">io</span><span class="o">::</span><span class="n">ZeroCopyOutputStream</span><span class="o">*</span> <span class="n">output</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">SerializePartialToString</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span> <span class="n">output</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">SerializePartialToArray</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">SerializePartialAsString</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">SerializePartialToFileDescriptor</span><span class="p">(</span><span class="kt">int</span> <span class="n">file_descriptor</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">SerializePartialToOstream</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">*</span> <span class="n">output</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">AppendPartialToString</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span> <span class="n">output</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这些序列化方法的输出各有不同，但最终都会转换为 <code class="language-plaintext highlighter-rouge">io::EpsCopyOutputStream</code> 传入给 PB 对象的 <code class="language-plaintext highlighter-rouge">_InternalSerialize()</code> 方法。</p>

<p><img class="mermaid" src="https://mermaid.ink/svg/eyJjb2RlIjoiY2xhc3NEaWFncmFtXG4lJS1cbmNsYXNzIFplcm9Db3B5T3V0cHV0U3RyZWFtIHtcbjw8aW50ZXJmYWNlPj5cbn1cbiUlLVxuY2xhc3MgQXJyYXlPdXRwdXRTdHJlYW1cbmNsYXNzIE9zdHJlYW1PdXRwdXRTdHJlYW1cbmNsYXNzIEZpbGVPdXRwdXRTdHJlYW1cbmNsYXNzIEVwc0NvcHlPdXRwdXRTdHJlYW1cbiUlLVxuWmVyb0NvcHlPdXRwdXRTdHJlYW0gPHwtLSBBcnJheU91dHB1dFN0cmVhbVxuWmVyb0NvcHlPdXRwdXRTdHJlYW0gPHwtLSBPc3RyZWFtT3V0cHV0U3RyZWFtXG5aZXJvQ29weU91dHB1dFN0cmVhbSA8fC0tIEZpbGVPdXRwdXRTdHJlYW1cbkVwc0NvcHlPdXRwdXRTdHJlYW0gLS0-IFplcm9Db3B5T3V0cHV0U3RyZWFtIiwibWVybWFpZCI6bnVsbH0" /></p>

<p>上面类图说明了 OutputStream 之间的关系，有若干具体类实现了<code class="language-plaintext highlighter-rouge">ZeroCopyOutputStream</code> 接口，这些具体类分别用于序列化到数组或字符串、<code class="language-plaintext highlighter-rouge">std::ostream</code>、文件描述符。</p>

<p><code class="language-plaintext highlighter-rouge">ZeroCopyOutputStream</code> 接口定义了如何申请和退回内存的逻辑，<code class="language-plaintext highlighter-rouge">EpsCopyOutputStream</code> 调用它的方法申请内存，随后写入各种数据。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ZeroCopyOutputStream</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="c1">// 获取一个可写的内存块，返回这个内存块的地址和大小</span>
  <span class="c1">// 如果内存块不够大，会再次调用 Next() 去申请</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">Next</span><span class="p">(</span><span class="kt">void</span><span class="o">**</span> <span class="n">data</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">size</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// 序列化结束了，退回多余的内存块</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">BackUp</span><span class="p">(</span><span class="kt">int</span> <span class="n">count</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// 返回目前已经分配的内存总大小</span>
  <span class="k">virtual</span> <span class="kt">int64_t</span> <span class="n">ByteCount</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>值得注意的是用户可以自己实现 <code class="language-plaintext highlighter-rouge">ZeroCopyOutputStream</code> 接口，随后调用 <code class="language-plaintext highlighter-rouge">SerializeToZeroCopyStream()</code> 进行序列化，从而自定义内存分配过程。比如可以每次 <code class="language-plaintext highlighter-rouge">Next()</code> 被调用都分配一块新的内存，最后把 PB 消息序列化到多块内存上。</p>

<h3 id="parse-接口">Parse 接口</h3>

<p>PB 对象的基类 <code class="language-plaintext highlighter-rouge">google::protobuf::MessageLite</code> 提供了许多反序列化用的方法:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MessageLite</span> <span class="p">{</span>
  <span class="kt">bool</span> <span class="n">ParseFromCodedStream</span><span class="p">(</span><span class="n">io</span><span class="o">::</span><span class="n">CodedInputStream</span><span class="o">*</span> <span class="n">input</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="n">ParseFromZeroCopyStream</span><span class="p">(</span><span class="n">io</span><span class="o">::</span><span class="n">ZeroCopyInputStream</span><span class="o">*</span> <span class="n">input</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="n">ParseFromFileDescriptor</span><span class="p">(</span><span class="kt">int</span> <span class="n">file_descriptor</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="n">ParseFromIstream</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">*</span> <span class="n">input</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="n">ParseFromString</span><span class="p">(</span><span class="n">ConstStringParam</span> <span class="n">data</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="n">ParseFromArray</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">);</span>

  <span class="c1">// ParsePartialFrom* 系列方法，未列出</span>
<span class="p">}</span>
</code></pre></div></div>

<p>类似的，可以自行实现 <code class="language-plaintext highlighter-rouge">ZeroCopyInputStream</code> 接口：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ZeroCopyInputStream</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="c1">// 获取一块可供读取的内存</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">Next</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span><span class="o">**</span> <span class="n">data</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">size</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// 上层读取到某个阶段时，发现剩余数据不足以完整读取了，就会退回剩余数据。</span>
  <span class="c1">// 下次调用 Next() 时需要返回更多数据</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">BackUp</span><span class="p">(</span><span class="kt">int</span> <span class="n">count</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// 跳过一部分数据</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">Skip</span><span class="p">(</span><span class="kt">int</span> <span class="n">count</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// 已经提供的内存总大小</span>
  <span class="k">virtual</span> <span class="kt">int64_t</span> <span class="n">ByteCount</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>]]></content><author><name></name></author></entry></feed>