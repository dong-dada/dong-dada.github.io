<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>std::shared_ptr 的线程安全性 | 董哒哒</title>
<meta name="generator" content="Jekyll v4.3.3">
<meta property="og:title" content="std::shared_ptr 的线程安全性">
<meta property="og:locale" content="en_US">
<meta name="description" content="我哒哒的马蹄是美丽的错误，我不是归人，是个过客">
<meta property="og:description" content="我哒哒的马蹄是美丽的错误，我不是归人，是个过客">
<link rel="canonical" href="/2024/08/27/shared-ptr-thread-safe.html">
<meta property="og:url" content="/2024/08/27/shared-ptr-thread-safe.html">
<meta property="og:site_name" content="董哒哒">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2024-08-27T04:00:00+00:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="std::shared_ptr 的线程安全性">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-08-27T04:00:00+00:00","datePublished":"2024-08-27T04:00:00+00:00","description":"我哒哒的马蹄是美丽的错误，我不是归人，是个过客","headline":"std::shared_ptr 的线程安全性","mainEntityOfPage":{"@type":"WebPage","@id":"/2024/08/27/shared-ptr-thread-safe.html"},"url":"/2024/08/27/shared-ptr-thread-safe.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css">
<link type="application/atom+xml" rel="alternate" href="/feed.xml" title="董哒哒">
</head>
<body>
<header class="site-header" role="banner">

  <div class="wrapper">
<a class="site-title" rel="author" href="/">董哒哒</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger">
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewbox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
            </svg>
          </span>
        </label>

        <div class="trigger"></div>
      </nav>
</div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">std::shared_ptr 的线程安全性</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2024-08-27T04:00:00+00:00" itemprop="datePublished">Aug 27, 2024
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <ul id="markdown-toc">
  <li><a href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7" id="markdown-toc-线程安全性">线程安全性</a></li>
  <li><a href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86" id="markdown-toc-实现原理">实现原理</a></li>
  <li><a href="#%E5%BA%94%E7%94%A8" id="markdown-toc-应用">应用</a></li>
</ul>

<h2 id="线程安全性">线程安全性</h2>

<p>关于 <code class="language-plaintext highlighter-rouge">std::shared_ptr</code> 的线程安全性, <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr">cppreference</a> 中提到:</p>
<blockquote>
  <p>All member functions (including copy constructor and copy assignment) can be called by multiple threads on different shared_ptr objects without additional synchronization even if these objects are copies and share ownership of the same object. If multiple threads of execution access the same shared_ptr object without synchronization and any of those accesses uses a non-const member function of shared_ptr then a data race will occur; the std::atomic<shared_ptr> can be used to prevent the data race.</shared_ptr></p>
</blockquote>

<p>前面一句话的意思是“即使不同线程中的不同 shared_ptr 指向相同对象，也可以安全地调用所有成员函数”。后面一句话的意思是“如果在多个线程中访问同一个 shared_ptr 指针，其中有线程使用了非 const 成员，那么会出现发生数据争用，此时可以使用 <code class="language-plaintext highlighter-rouge">std::atomic&lt;shared_ptr&gt;</code>”。</p>

<p>也就是说下面的代码是线程安全的，尽管不能确定对象是在哪个线程中被释放，但是可以保证对象只被释放一次:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p1</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>

  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">([</span><span class="n">p1</span><span class="p">]()</span> <span class="p">{</span>
    <span class="c1">// p1 和 p2 指向同一个对象</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">p1</span><span class="p">;</span>

    <span class="c1">// 释放 p1 和 p2</span>
    <span class="n">p1</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
    <span class="n">p2</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
  <span class="p">});</span>

  <span class="c1">// 释放 p1</span>
  <span class="n">p1</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
  <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>但下面代码不是线程安全的，因为在两个线程中访问了同一个 <code class="language-plaintext highlighter-rouge">std::shared_ptr</code> 指针:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p1</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>

  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">([</span><span class="o">&amp;</span><span class="n">p1</span><span class="p">]()</span> <span class="p">{</span>
    <span class="c1">// 使用 p1</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p1</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">});</span>

  <span class="c1">// 释放 p1</span>
  <span class="n">p1</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
  <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="实现原理">实现原理</h2>

<p>实现上通常是通过原子操作来保障线程安全性的，如以下伪代码所示，通过原子操作可以保证只有一个线程进入析构步骤：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">shared_ptr</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="o">~</span><span class="n">shared_ptr</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 将引用计数原子地减一，返回原先的值</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">shared_count_</span><span class="o">-&gt;</span><span class="n">fetch_sub</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 只会有一个线程进入这个步骤</span>
      <span class="k">delete</span> <span class="n">data_</span><span class="p">;</span>
      <span class="k">delete</span> <span class="n">shared_count_</span><span class="p">;</span>     <span class="c1">// 这一步会有线程安全问题吗？</span>
    <span class="p">}</span>
  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="n">T</span><span class="o">*</span> <span class="n">data_</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">atomic_int</span><span class="o">*</span> <span class="n">shared_count_</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>上述代码中 <code class="language-plaintext highlighter-rouge">delete shared_count_</code> 可能引起疑问，如果在线程 A 中执行了这一句，在线程 B 中又试图访问 <code class="language-plaintext highlighter-rouge">shared_count_</code> 应该会有线程安全问题。</p>

<p>但这种情况只会出现在 “多个线程访问同一个 <code class="language-plaintext highlighter-rouge">shared_ptr</code> 的场景下”，如果我们遵循正确的使用方式，让线程 A 和 B 持有各自的 <code class="language-plaintext highlighter-rouge">shared_ptr</code> 拷贝，那么线程 A 和 B 同时进入析构函数的情况下，<code class="language-plaintext highlighter-rouge">shared_count_</code> 至少是 2，只有在线程 B 已经将其减为 1 的情况下，线程 A 才有机会执行到 <code class="language-plaintext highlighter-rouge">delete shared_count_</code> 这一句。所以上述代码不存在线程安全问题。</p>

<p>总的来说，向其它线程传递 <code class="language-plaintext highlighter-rouge">std::shared_ptr</code> 时应该以拷贝的方式传递，这样就不会有线程安全问题。</p>

<h2 id="应用">应用</h2>

<p>以上内容表明在多个线程中通过不同 <code class="language-plaintext highlighter-rouge">std::shared_ptr</code> 指向同一个对象是线程安全的。当然这是针对 <code class="language-plaintext highlighter-rouge">std::shared_ptr</code> 本身而言，对于它所指向的对象还是需要加锁的。</p>

<p>一种有趣的应用是利用 <code class="language-plaintext highlighter-rouge">std::shared_ptr</code> 的引用计数及自定义析构函数来判断并行的一批任务是否全部完成:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">runOnAllThreads</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">all_threads_complete_cb</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">cb_guard</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">),</span> <span class="p">[</span><span class="n">all_threads_complete_cb</span><span class="p">](</span><span class="kt">int</span><span class="o">*</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 自定义析构函数</span>
    <span class="c1">// 对象被析构意味着所有线程执行完毕</span>
    <span class="n">all_threads_complete_cb</span><span class="p">();</span>
    <span class="k">delete</span> <span class="n">obj</span><span class="p">;</span>
  <span class="p">});</span>

  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="kr">thread</span> <span class="o">:</span> <span class="n">threads</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">thread</span><span class="p">.</span><span class="n">post</span><span class="p">([</span><span class="n">cb_guard</span><span class="p">]()</span> <span class="p">{</span>
      <span class="c1">// 每个线程执行后都触发这个回调</span>
      <span class="c1">// 全部线程执行完毕后, cb_guard 的引用计数减为 0, 触发析构函数</span>
    <span class="p">});</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

  </div>

  <script src="https://giscus.app/client.js" data-repo="dong-dada/dong-dada.github.io" data-repo-id="R_kgDOMmKAUg" data-category="Comments" data-category-id="DIC_kwDOMmKAUs4Ch6E0" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async>
  </script>

  <a class="u-url" href="/2024/08/27/shared-ptr-thread-safe.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/%20/"></data>

  <div class="wrapper">

    <!--
    <h2 class="footer-heading">董哒哒</h2>
    -->

    <div class="footer-col-wrapper">
      <!--
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">董哒哒</li>
        </ul>
      </div>
      -->

      <div class="footer-col footer-col-2">
<ul class="social-media-list">
<li><a href="https://github.com/dong-dada"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">dong-dada</span></a></li>
<li><a class="u-email" href="mailto:dongyu_1991@outlook.com"><span class="icon svg-icon"><?xml version="1.0" standalone="no"?><svg t="1724212825924" class="icon" viewbox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1715" xmlns:xlink="http://www.w3.org/1999/xlink" width="16" height="16"><path d="M153.236734 163.111422l714.763665 0c48.810633 0 88.718697 38.475467 89.332667 85.853503l-446.458679 242.518237L64.313381 249.169581C64.722694 201.689218 104.323773 163.111422 153.236734 163.111422L153.236734 163.111422zM64.313381 341.981413l-0.409313 429.062856c0 47.787349 40.215049 86.876786 89.332667 86.876786l714.763665 0c49.117618 0 89.332667-39.089437 89.332667-86.876786L957.333067 341.776756 521.311882 573.038873c-6.651344 3.581493-14.735285 3.581493-21.386629 0L64.313381 341.981413 64.313381 341.981413zM64.313381 341.981413" p-id="1716" fill="#828282"></path></svg></span>  <span class="username">dongyu_1991@outlook.com</span></a></li>
</ul>
</div>

      <div class="footer-col footer-col-3">
        <p>我哒哒的马蹄是美丽的错误，我不是归人，是个过客</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
