<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>RDMA 学习 | 董哒哒</title>
<meta name="generator" content="Jekyll v4.3.3">
<meta property="og:title" content="RDMA 学习">
<meta property="og:locale" content="en_US">
<meta name="description" content="我哒哒的马蹄是美丽的错误，我不是归人，是个过客">
<meta property="og:description" content="我哒哒的马蹄是美丽的错误，我不是归人，是个过客">
<link rel="canonical" href="/2024/08/28/rdma-learn.html">
<meta property="og:url" content="/2024/08/28/rdma-learn.html">
<meta property="og:site_name" content="董哒哒">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2024-08-28T04:00:00+00:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="RDMA 学习">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-08-28T04:00:00+00:00","datePublished":"2024-08-28T04:00:00+00:00","description":"我哒哒的马蹄是美丽的错误，我不是归人，是个过客","headline":"RDMA 学习","mainEntityOfPage":{"@type":"WebPage","@id":"/2024/08/28/rdma-learn.html"},"url":"/2024/08/28/rdma-learn.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css">
<link type="application/atom+xml" rel="alternate" href="/feed.xml" title="董哒哒">
</head>
<body>
<header class="site-header" role="banner">

  <div class="wrapper">
<a class="site-title" rel="author" href="/">董哒哒</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger">
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewbox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
            </svg>
          </span>
        </label>

        <div class="trigger"></div>
      </nav>
</div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">RDMA 学习</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2024-08-28T04:00:00+00:00" itemprop="datePublished">Aug 28, 2024
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <ul id="markdown-toc">
  <li><a href="#%E6%A6%82%E8%BF%B0" id="markdown-toc-概述">概述</a></li>
  <li>
<a href="#verbs-api" id="markdown-toc-verbs-api">Verbs API</a>    <ul>
      <li><a href="#%E6%9C%8D%E5%8A%A1%E7%B1%BB%E5%9E%8B" id="markdown-toc-服务类型">服务类型</a></li>
      <li><a href="#rc-%E5%BB%BA%E8%BF%9E" id="markdown-toc-rc-建连">RC 建连</a></li>
      <li>
<a href="#%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%9E%8B" id="markdown-toc-操作类型">操作类型</a>        <ul>
          <li><a href="#sendrecv" id="markdown-toc-sendrecv">Send&amp;Recv</a></li>
          <li><a href="#write" id="markdown-toc-write">Write</a></li>
          <li><a href="#read" id="markdown-toc-read">Read</a></li>
        </ul>
      </li>
      <li><a href="#memory-region" id="markdown-toc-memory-region">Memory Region</a></li>
    </ul>
  </li>
  <li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99" id="markdown-toc-参考资料">参考资料</a></li>
</ul>

<h2 id="概述">概述</h2>

<p>RDMA 是 Remote Direct Memory Access 的缩写，意为”远程直接内存访问”，它的基本原理是绕过 CPU 和 操作系统，让通信两端的网卡直接访问用户态内存，完成数据传输。</p>

<p>这种做法省去了上下文切换、内存拷贝、协议处理等开销，在数据传输时能达到较高的带宽和延迟指标：</p>

<p><img src="/images/networking/traditional-vs-rdma.png" alt=""></p>

<p>RDMA 技术有几种不同的协议栈实现，但在应用层提供了统一的接口，称为 Verbs API:</p>

<p><img src="/images/networking/rdma-protocol-stack.png" alt=""></p>

<p>InfiniBand 协议栈需要添置专门的网络设备，无法兼容现有以太网，除了需要支持 IB 的网卡，还需要配套的交换设备。RoCE 协议栈可以看作是“低成本解决方案”，目的是在以太网中运行 RDMA。早期的 RoCE 仅支持在二层以太网上实现 RDMA 传输，换句话说报文没法被路由器路由，使用场景受限。随后的 RoCEv2 把报文封装在了 UDP/IP 报文内，可以跨越子网路由，解除了诸多限制，逐渐流行起来。</p>

<p>值得注意的是上图左侧标明的 “Hardware”，就是说 RDMA 协议栈需要专门的网卡实现，一般网卡是不行的。</p>

<p>下图是 RoCE 和 RoCEv2 的报文结构：</p>

<p><img src="/images/networking/roce-packet-format.jpeg" alt=""></p>

<p>RoCEv2 可以工作在 lossless 和 lossy 网络下：</p>
<ul>
  <li>Lossless，也就是无损以太网，要求网络中没有差错、丢包、乱序。实现 lossless 需要支持该功能的网卡、交换机，并进行相应的网络配置。涉及的技术包括：
    <ul>
      <li>PFC: Priority Flow Control, 基于优先级的流量控制，让 RDMA 流量具有更高的优先级。</li>
      <li>DCB: Data Center Bridging, 增强的以太网协议，支持无损传输。</li>
      <li>ECN: Explicit Congestion Notification, 显式拥塞通知，交换机发生拥塞会显式通知发送方，发送方可以降低速率。</li>
    </ul>
  </li>
  <li>Lossy, 也就是有损网络，自 CX5 系列网卡开始支持 RoCE 的增强功能，使得组网规模不大的情况下，也能在 lossy 网络中运行。</li>
</ul>

<h2 id="verbs-api">Verbs API</h2>

<p>跟 Socket API 相比，Verbs API 有些复杂，首先需要理解队列模型：</p>

<p><img src="/images/networking/rdma-consumer-queuing-model.png" alt=""></p>

<p>通过 Verbs API 进行数据传输时，需要向 Work Queue 里投递 Work Request, 网卡(HCA)从队列里取出 WQE 执行相应操作，结束后会投递一个 CQE 到 Completion Queue 里，应用层可以从这个队列中取出 Work Completion 得知处理结果。</p>

<p>以下代码片段展示了这一过程:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">main</span> <span class="p">{</span>
    <span class="c1">// QP 建连、注册 MR 等过程，省略。。。</span>

    <span class="c1">// 要发送的内存块信息</span>
    <span class="n">ibv_sge</span> <span class="n">sg</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">local_mr</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span>
        <span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">local_mr</span><span class="p">.</span><span class="n">length</span><span class="p">,</span>
        <span class="p">.</span><span class="n">lkey</span> <span class="o">=</span> <span class="n">local_mr</span><span class="p">.</span><span class="n">lkey</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="c1">// 构造 Work Request, 内容为使用 WRITE 操作，将内存块写入目标地址</span>
    <span class="n">ibv_send_wr</span> <span class="n">write_wr</span><span class="p">{</span>
        <span class="p">.</span><span class="n">wr_id</span> <span class="o">=</span> <span class="n">wr_id</span><span class="p">,</span>
        <span class="p">.</span><span class="n">sg_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sg</span><span class="p">,</span>                     <span class="c1">// 要发送的内存块</span>
        <span class="p">.</span><span class="n">num_sge</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="p">.</span><span class="n">opcode</span> <span class="o">=</span> <span class="n">IBV_WR_RDMA_WRITE</span><span class="p">,</span>        <span class="c1">// 操作方式</span>
        <span class="p">.</span><span class="n">send_flags</span> <span class="o">=</span> <span class="n">IBV_SEND_SIGNALED</span><span class="p">,</span>
        <span class="p">.</span><span class="n">wr</span> <span class="o">=</span> <span class="p">{</span>
            <span class="p">.</span><span class="n">rdma</span> <span class="o">=</span> <span class="p">{</span>
                <span class="p">.</span><span class="n">remote_addr</span> <span class="o">=</span> <span class="n">remote_addr</span><span class="p">,</span> <span class="c1">// 远端内存地址信息</span>
                <span class="p">.</span><span class="n">rkey</span> <span class="o">=</span> <span class="n">remote_key</span><span class="p">,</span>
            <span class="p">},</span>
        <span class="p">},</span>
    <span class="p">};</span>

    <span class="c1">// 将 Work Request 投递到 Send Queue</span>
    <span class="n">ibv_send_wr</span><span class="o">*</span> <span class="n">bad_send_wr</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ibv_post_send</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_qp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">write_wr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bad_send_wr</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"Failed to post write wr, errno: %d(%s)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">errno</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">sleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>

    <span class="c1">// 从 Completion Queue 里取出 Work Completion</span>
    <span class="n">ibv_wc</span> <span class="n">wc_list</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ibv_poll_cq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_cq</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">wc_list</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"Failed to poll work completions from cq, errno: %d(%s)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">errno</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 检查是否执行成功</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">wc</span><span class="p">.</span><span class="n">status</span> <span class="o">!=</span> <span class="n">IBV_WC_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Failed WC status %d(%s) for wr_id %lu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">wc</span><span class="p">.</span><span class="n">status</span><span class="p">,</span> <span class="n">ibv_wc_status_str</span><span class="p">(</span><span class="n">wc</span><span class="p">.</span><span class="n">status</span><span class="p">),</span> <span class="n">wc</span><span class="p">.</span><span class="n">wr_id</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>理解了队列模型之后，剩余的概念就比较好解释了：</p>

<table>
  <thead>
    <tr>
      <th>概念</th>
      <th>缩写</th>
      <th>解释</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Send Queue</td>
      <td>SQ</td>
      <td>发送队列，顾名思义用于存放发送任务。<br>在 API 中使用 <code class="language-plaintext highlighter-rouge">ibv_post_send()</code> 方法向该队列投递任务，对应结构体 <code class="language-plaintext highlighter-rouge">ibv_send_wr</code>
</td>
    </tr>
    <tr>
      <td>Receive Queue</td>
      <td>RQ</td>
      <td>接收队列，用于存放接收任务。<br>适用于 SEND&amp;RECV 操作，在这种操作模式下，不仅发送方需要向 SQ 中投递发送任务，接收方也需要在 RQ 中投递接收任务，这样才能收到数据。<br>在 API 中使用 <code class="language-plaintext highlighter-rouge">ibv_recv_wr</code> 投递接收任务，对应结构体 <code class="language-plaintext highlighter-rouge">ibv_recv_wr</code>
</td>
    </tr>
    <tr>
      <td>Queue Pair</td>
      <td>QP</td>
      <td>也就是一对 SQ 和 RQ。<br>QP 和 QP 之间可以绑定起来建立连接关系。<br>QP 有一个编号来标识，称为 Queue Pair Number, 简称 QPN。</td>
    </tr>
    <tr>
      <td>Shared Receive Queue</td>
      <td>SRQ</td>
      <td>多个 QP 共享一个 Receive Queue, 从上面讨论可以看出 Receive Queue 的使用频率比较低，大多数情况下是在使用 Send Queue, 因此可以通过共享来节省资源。</td>
    </tr>
    <tr>
      <td>Memory Region</td>
      <td>MR</td>
      <td>用户态申请的内存不能直接被网卡访问，需要先注册到 Memory Region 上。<br>在 API 中使用 <code class="language-plaintext highlighter-rouge">ibv_reg_mr()</code> 注册 MR, 使用 <code class="language-plaintext highlighter-rouge">ibv_dereg_mr()</code> 取消注册，对应结构体 <code class="language-plaintext highlighter-rouge">ibv_mr</code>
</td>
    </tr>
    <tr>
      <td>Memory Window</td>
      <td>MW</td>
      <td>相当于时 MR 上某个区域的视图，可以针对这个视图做权限修改，相比于重新注册 MR 来说速度很快。</td>
    </tr>
    <tr>
      <td>Protection Domain</td>
      <td>PD</td>
      <td>用于保护各类资源，包括 QP, MR 等，相当于对这些资源进行分组，不同组的资源彼此隔离。<br>在 API 中使用 <code class="language-plaintext highlighter-rouge">ibv_create_qp()</code> 创建 PD, 使用 <code class="language-plaintext highlighter-rouge">ibv_dealloc_pd()</code> 释放 PD, 对应结构体 <code class="language-plaintext highlighter-rouge">ibv_pd</code>
</td>
    </tr>
    <tr>
      <td>Completion Queue</td>
      <td>CQ</td>
      <td>完成队列，硬件每处理完一个 WQE，就会投递一个 CQE 到 CQ 里面。应用可以从中获取出 Work Completion，得知处理结果。<br>注意一个 CQ 可以为多个 QP 提供服务。<br>在 API 中使用 <code class="language-plaintext highlighter-rouge">ibv_poll_cq()</code> 获取 WC, 对应结构体 <code class="language-plaintext highlighter-rouge">ibv_wc</code>
</td>
    </tr>
    <tr>
      <td>Completion Event Channel</td>
      <td> </td>
      <td>能够使用事件驱动的方式来获取 WC, 而不是通过 poll 模式获取。可以跟若干 CQ 关联起来，每当 CQ 上有了 WC，就可以从 Channnel 中收到事件通知。<br>在 API 中使用 <code class="language-plaintext highlighter-rouge">ibv_create_comp_channel()</code> 创建 channel，使用 <code class="language-plaintext highlighter-rouge">ibv_create_cq()</code> 创建 CQ 时传入 channel 即可进行绑定，使用 <code class="language-plaintext highlighter-rouge">ibv_req_notify_cq()</code> 要求 CQ 通过 channel 进行事件通知，使用 <code class="language-plaintext highlighter-rouge">ibv_get_cq_event()</code> 从 Channel 中阻塞式地获取 CQE, 使用 <code class="language-plaintext highlighter-rouge">ibv_ack_cq_events()</code> 确认 CQE。Channel 中有个 fd, 可以跟 epoll 结合使用，<a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_5/rust-epoll-rdma.html">这篇文章</a> 描述了具体做法。<br>相比 Poll 模式，这种方式可以节省 CPU 占用，但性能上有一定损失。事件模式 和 Poll 模式可以结合使用，在收到事件之后的一段时间内轮询调用 <code class="language-plaintext highlighter-rouge">ibv_poll_cq()</code> 主动获取 WC。</td>
    </tr>
  </tbody>
</table>

<p>RDMA 通信过程可以分为以下几个步骤：</p>
<ul>
  <li>创建资源，包括 PD, QP, CQ, CompChannel 等。</li>
  <li>建立连接</li>
  <li>注册内存到 MR，这一步是比较耗时的，通常需要对注册好的内存池化管理。</li>
  <li>数据传输</li>
</ul>

<h3 id="服务类型">服务类型</h3>

<p>基于 QP 的服务类型通过 “可靠性” 和 “连接” 两个维度划分为四种：</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>可靠(Reliable)</th>
      <th>不可靠(Unreliable)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>连接</td>
      <td>RC(Reliable Connection)</td>
      <td>UC(Unreliable Connection)</td>
    </tr>
    <tr>
      <td>数据报</td>
      <td>RD(Reliable Datagram)</td>
      <td>UD(Unreliable Datagram)</td>
    </tr>
  </tbody>
</table>

<p>可以看到 RC 类似于 TCP, 通信之前要先建立连接；UD 类似于 TCP，每次发送都需要传入地址信息。</p>

<h3 id="rc-建连">RC 建连</h3>

<p>在 TCP 中，建立连接需要 IP 和 Port 两个信息，在 RDMA 中建立 RC 连接需要哪些信息呢？</p>

<p>虽然 RoCEv2 是基于 UDP 的，但它遵循的是 IB 协议，因此从 API 层面并不能看到 UDP 的 IP 和 Port 信息。以下是 RDMA 中地址信息相关的概念：</p>

<table>
  <thead>
    <tr>
      <th>概念</th>
      <th>缩写</th>
      <th>解释</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Global Identifier</td>
      <td>GID</td>
      <td>类似于 IP 地址在 TCP/IP 网络中的作用。是一个 128 位的地址，由 64 位的子网前缀和 64 位的接口标识符组成。用于跨越子网的通信。<br>RoCE 中的 GID 通常由 IPv6 派生而来。</td>
    </tr>
    <tr>
      <td>Local Identifier</td>
      <td>LID</td>
      <td>类似于 MAC 地址。是一个 16 位的局部标识符，用于标识 InfiniBand 子网中的某个设备。用于子网内的通信。<br>RoCE 中不需要，它基于 MAC 地址进行子网内部通信。</td>
    </tr>
    <tr>
      <td>Port Number</td>
      <td> </td>
      <td>RDMA设备(如 HCA, Host Channel Adapter 也就是网卡)上通常有多个物理端口，每个端口连接到一个独立的网络。这个物理端口以 Port Number 序号进行标识，通常从 1 开始编号。<br>每个端口都有独立的地址信息，包括 GID, LID 等，因此先要指定 Port Number 才能找到 GID</td>
    </tr>
    <tr>
      <td>GID Index</td>
      <td> </td>
      <td>每个 Port Number 对应的物理端口上，可以有多个 GID，这些 GID 组成了一个 GID 表，GID Index 就是表中的索引。<br>这个 GID 表通常用于支持不同类型的地址，比如基于 LID 的 GID、IPv6 地址。 <br>对于 RoCE 来说, Index 为 0 的 GID 由 MAC 地址生成，Index 为 1 的 GID 由 IPv4 地址生成，Index 为 2 的 GID 由 IPv6 地址生成。</td>
    </tr>
    <tr>
      <td>Queue Pair Number</td>
      <td>QPN</td>
      <td>即 QP 的编号</td>
    </tr>
    <tr>
      <td>Packet Sequence Number</td>
      <td>PSN</td>
      <td>类似于 TCP 握手时交换的 seq 序号，在 RC 建连时需要手动指定。</td>
    </tr>
    <tr>
      <td>Address Handle</td>
      <td>AH</td>
      <td>封装了地址信息，用于 UD 服务类型，每次发送都需要填入目标地址，AH 提供了目标地址信息的封装，免得每次重新创建。</td>
    </tr>
  </tbody>
</table>

<p>从上面内容来看，建立 RC 连接时至少需要收集 GID, QPN, PSN 这三项信息。以下代码展示了如何获得这些信息:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="n">kPortNum</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>   <span class="c1">// 选择默认物理端口</span>
    <span class="kt">int</span> <span class="n">kGidIndex</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>      <span class="c1">// 选择 IPv6 GID</span>

    <span class="c1">// 打开设备</span>
    <span class="n">ibv_context</span><span class="o">*</span> <span class="n">context</span> <span class="o">=</span> <span class="n">ibv_open_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>

    <span class="c1">// 创建 QP, 省略 PD 等细节</span>
    <span class="n">ibv_qp</span><span class="o">*</span> <span class="n">qp</span> <span class="o">=</span> <span class="n">ibv_create_qp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qp_init_attr</span><span class="p">);</span>
    
    <span class="c1">// 查询 GID</span>
    <span class="n">ibv_gid</span> <span class="n">gid</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ibv_query_gid</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">kPortNum</span><span class="p">,</span> <span class="n">kGidIndex</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gid</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"Failed to query gid, port_num: %d, gid_index: %d, errno: %d(%s)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">port_num</span><span class="p">,</span> <span class="n">gid_index</span><span class="p">,</span> <span class="n">errno</span><span class="p">,</span>
             <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 查询 QPN</span>
    <span class="kt">uint32_t</span> <span class="n">qpn</span> <span class="o">=</span> <span class="n">qp</span><span class="p">.</span><span class="n">qp_num</span><span class="p">;</span>

    <span class="c1">// 生成 PSN</span>
    <span class="kt">int</span> <span class="n">psn</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">lrand48</span><span class="p">()</span> <span class="o">&amp;</span> <span class="mh">0xffffff</span><span class="p">);</span>

    <span class="c1">// 通过带外方式，通信双方交换 GID, QPN, PSN 信息</span>
    <span class="c1">// 随后进行 RC 建连</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这些信息的交换是带外的，RDMA CM(Communication Manager) 是一个专门用来做连接管理的库。也可以使用 TCP 连接等方式来交换信息。</p>

<p>拿到这些信息之后，需要调用 <code class="language-plaintext highlighter-rouge">ibv_modify_qp()</code> 方法，建立 RC 连接。建连的过程稍微有些复杂，需要执行三次 modify qp 操作，逐步切换状态: Reset -&gt; Initialized -&gt; Read to Receive -&gt; Ready to Send</p>

<p><img src="/images/networking/rdma-qp-state.png" alt=""></p>

<h3 id="操作类型">操作类型</h3>

<p>RDMA 提供了几种不同的操作类型，用于不同场景:</p>

<h4 id="sendrecv">Send&amp;Recv</h4>

<p>如下图，这种方式需要通信两端都都参与，发送方投递 SEND 任务，接收方投递 RECV 任务：</p>
<ul>
  <li>这种方式适合于发送一些控制消息，不太适合大块数据的传输。</li>
  <li>它要求接收方提前投递 RECV 任务到接收队列里面，并且接收方需要准备一块内存来接收数据。</li>
  <li>在这种方式下，接收方能够通过 CQ 判断是否有新数据到来。</li>
</ul>

<p><img src="/images/networking/rdma-send-recv.png" alt=""></p>

<h4 id="write">Write</h4>

<p>如下图，这种方式是单端操作，接收方需要事先准备一块内存，并且把内存信息通过某种方式告知给发送方，发送方将自己数据写入到接收方的内存中，写入的过程不需要接收方参与。</p>
<ul>
  <li>接收方可以通过 Send&amp;Recv 的方式将自己的内存信息告诉发送方。</li>
  <li>接收方默认是不知道数据已经收到的，发送方可以在发送时指定 IBV_WR_RDMA_WRITE_WITH_IMM, 这样接收方会在 RQ 里额外收到一个消息。当然发送方也可以在 WRITE 完成之后再通过 Send&amp;Recv 通知一下接收方。</li>
</ul>

<p><img src="/images/networking/rdma-write.png" alt=""></p>

<h4 id="read">Read</h4>

<p>Read 操作是跟 Write 相反的过程，是从远端拷贝一份数据到本端上。同样远端需要事先通过某种方式把内存信息告知过来。</p>
<ul>
  <li>同样的，远端机器并不知道自己的数据已经被读取完成了，需要本端通过 Send&amp;Recv 等方式通知远端。</li>
</ul>

<p><img src="/images/networking/rdma-read.png" alt=""></p>

<h3 id="memory-region">Memory Region</h3>

<p>调用 <code class="language-plaintext highlighter-rouge">ibv_reg_mr()</code> 即可将一块用户态内存注册到 MR 中:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ibv_mr</span><span class="o">*</span> <span class="nf">allocMemAndRegMr</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">mem_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 申请内存，并且要求进行页对齐</span>
    <span class="c1">// 对齐并不是强制的，但是 ChatGPT 说页对齐之后性能会好点，没找到出处</span>
    <span class="c1">// rdma-core 的 pingpong 示例程序里也是进行了页对齐的</span>
    <span class="kt">size_t</span> <span class="n">alignment</span> <span class="o">=</span> <span class="n">_SC_PAGESIZE</span><span class="p">;</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">mem_addr</span> <span class="o">=</span> <span class="n">memalign</span><span class="p">(</span><span class="n">alignment</span><span class="p">,</span> <span class="n">mem_size</span><span class="p">);</span>

    <span class="c1">// 指定 MR 的访问权限</span>
    <span class="kt">int</span> <span class="n">access_flags_int</span> <span class="o">=</span> <span class="n">IBV_ACCESS_LOCAL_WRITE</span> <span class="o">|</span> <span class="n">IBV_ACCESS_REMOTE_WRITE</span><span class="p">;</span>

    <span class="c1">// 注册到 MR 上</span>
    <span class="n">ibv_mr</span><span class="o">*</span> <span class="n">mr</span> <span class="o">=</span> <span class="n">ibv_reg_mr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_pd</span><span class="p">,</span> <span class="n">mem_addr</span><span class="p">,</span> <span class="n">mem_size</span><span class="p">,</span> <span class="n">access_flags_int</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">mr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>注册后返回的 <code class="language-plaintext highlighter-rouge">ibv_mr</code> 是个结构体，其中包含了 lkey, rkey 两把钥匙。在执行不同任务时，需要按照需求带上相应的 key。具体可以参考 <a href="https://www.rdmamojo.com/2012/09/07/ibv_reg_mr/">RDMAmojo</a>.</p>

<h2 id="参考资料">参考资料</h2>

<ul>
  <li><a href="https://www.rdmamojo.com/">RDMAmojo</a></li>
  <li><a href="https://www.zhihu.com/column/c_1231181516811390976">RDMA杂谈 - 知乎</a></li>
  <li><a href="http://www.bj-joynet.com/static/upload/file/20221025/1666684563267006.pdf">端到端RoCE概念原理与部署调优</a></li>
  <li><a href="https://01.me/projects/SocksDirect/sigcomm19-transcription/">BojieLi</a></li>
  <li>
<a href="https://openucx.readthedocs.io/en/master/index.html">OpenUCX</a> 高性能通信框架</li>
</ul>

  </div>

  <script src="https://giscus.app/client.js" data-repo="dong-dada/dong-dada.github.io" data-repo-id="R_kgDOMmKAUg" data-category="Comments" data-category-id="DIC_kwDOMmKAUs4Ch6E0" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async>
  </script>

  <a class="u-url" href="/2024/08/28/rdma-learn.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/%20/"></data>

  <div class="wrapper">

    <!--
    <h2 class="footer-heading">董哒哒</h2>
    -->

    <div class="footer-col-wrapper">
      <!--
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">董哒哒</li>
        </ul>
      </div>
      -->

      <div class="footer-col footer-col-2">
<ul class="social-media-list">
<li><a href="https://github.com/dong-dada"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">dong-dada</span></a></li>
<li><a class="u-email" href="mailto:dongyu_1991@outlook.com"><span class="icon svg-icon"><?xml version="1.0" standalone="no"?><svg t="1724212825924" class="icon" viewbox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1715" xmlns:xlink="http://www.w3.org/1999/xlink" width="16" height="16"><path d="M153.236734 163.111422l714.763665 0c48.810633 0 88.718697 38.475467 89.332667 85.853503l-446.458679 242.518237L64.313381 249.169581C64.722694 201.689218 104.323773 163.111422 153.236734 163.111422L153.236734 163.111422zM64.313381 341.981413l-0.409313 429.062856c0 47.787349 40.215049 86.876786 89.332667 86.876786l714.763665 0c49.117618 0 89.332667-39.089437 89.332667-86.876786L957.333067 341.776756 521.311882 573.038873c-6.651344 3.581493-14.735285 3.581493-21.386629 0L64.313381 341.981413 64.313381 341.981413zM64.313381 341.981413" p-id="1716" fill="#828282"></path></svg></span>  <span class="username">dongyu_1991@outlook.com</span></a></li>
</ul>
</div>

      <div class="footer-col footer-col-3">
        <p>我哒哒的马蹄是美丽的错误，我不是归人，是个过客</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
